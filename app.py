# app.py
# AI-generated by GPT-4; please check for errors.
# Reverse proxy for the Replicate API endpoint for Cerebro (Phi-3.5-vision-instruct).
# This Lambda function receives an HTTP request, validates it against OpenAI's API standards,
# forwards it to the Replicate API, and returns the response.

import os
import json
import logging
import time
from typing import Dict, Any
import requests

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Environment variables
REPLICATE_MODEL_VERSION = os.environ.get(
    "REPLICATE_MODEL_VERSION",
    "eb47203b095603b4189c941667c3e21b7aba6694af845dae9a889a348581ed17",
)


def lambda_handler(event: Dict[str, Any], context):
    """
    AWS Lambda handler function.
    Receives an HTTP request, validates it according to OpenAI's API standards,
    forwards it to the Replicate API, and returns the response.
    """
    logger.info(f"Received event: {json.dumps(event)}")

    # Only accept POST requests
    if event.get("httpMethod") != "POST":
        logger.warning("Invalid HTTP method.")
        return {
            "statusCode": 405,
            "body": json.dumps(
                {
                    "error": {
                        "message": "Method Not Allowed. Only POST requests are accepted.",
                        "type": "invalid_request_error",
                    }
                }
            ),
            "headers": {"Content-Type": "application/json"},
        }

    try:
        # Extract API key from headers
        headers = event.get("headers", {})
        print(f"Headers: {headers}")
        api_key = headers.get("Authorization")

        if not api_key or not api_key.startswith("Bearer "):
            logger.warning("API key missing or improperly formatted.")
            return {
                "statusCode": 401,
                "body": json.dumps(
                    {
                        "error": {
                            "message": "API key is missing or invalid.",
                            "type": "authentication_error",
                        }
                    }
                ),
                "headers": {"Content-Type": "application/json"},
            }

        user_api_key = api_key.split("Bearer ")[1].strip()

        # Here you would validate the user's API key
        # For this example, we'll assume any non-empty key is valid
        if not user_api_key:
            logger.warning("Invalid API key provided.")
            return {
                "statusCode": 401,
                "body": json.dumps(
                    {
                        "error": {
                            "message": "API key is invalid.",
                            "type": "authentication_error",
                        }
                    }
                ),
                "headers": {"Content-Type": "application/json"},
            }

        try:
            # Parse the incoming request body
            body_raw = event.get("body", "{}")
            if isinstance(body_raw, str):
                body = json.loads(body_raw)
            else:
                body = body_raw  # Already a dictionary
        except json.JSONDecodeError:
            logger.warning("Invalid JSON in request body.")
            return {
                "statusCode": 400,
                "body": json.dumps(
                    {
                        "error": {
                            "type": "invalid_request_error",
                            "message": "The request body is not valid JSON.",
                        }
                    }
                ),
                "headers": {"Content-Type": "application/json"},
            }

        # Validate request body according to OpenAI's API schema
        prompt = body.get("prompt")
        # Accommodate both "url" and "image_urls" for flexibility
        image_urls = body.get("image_urls") or body.get("url")

        if not prompt or not image_urls:
            logger.warning("Missing 'prompt' or 'image_urls'/'url' in request body.")
            return {
                "statusCode": 400,
                "body": json.dumps(
                    {
                        "error": {
                            "message": "Request must include 'prompt' and ('image_urls' or 'url').",
                            "type": "invalid_request_error",
                        }
                    }
                ),
                "headers": {"Content-Type": "application/json"},
            }

        # Prepare the payload for Replicate API
        replicate_payload = {
            "version": REPLICATE_MODEL_VERSION,
            "input": {
                "prompt": prompt,
                "image_urls": image_urls,
                "max_new_tokens": body.get("max_tokens", 1000),
                "temperature": body.get("temperature", 0.7),
                "do_sample": body.get("do_sample", True),
            },
        }

        # Call the Replicate API to create a new prediction
        replicate_headers = {
            "Authorization": f"Bearer {user_api_key}",
            "Content-Type": "application/json",
        }
        response = requests.post(
            "https://api.replicate.com/v1/predictions",
            headers=replicate_headers,
            json=replicate_payload,
        )

        logger.info(f"Replicate API response status: {response.status_code}")

        if response.status_code != 201:
            logger.error(f"Replicate API error: {response.text}")
            return {
                "statusCode": 500,
                "body": json.dumps(
                    {
                        "error": {
                            "message": "Error from Replicate API.",
                            "details": response.text,
                            "type": "api_error",
                        }
                    }
                ),
                "headers": {"Content-Type": "application/json"},
            }

        # Get the prediction ID and start polling for completion
        prediction = response.json()
        prediction_id = prediction.get("id")
        prediction_status = prediction.get("status")

        # Poll for completion
        while prediction_status not in ["succeeded", "failed", "canceled"]:
            logger.info(f"Prediction status: {prediction_status}")
            time.sleep(1)  # Wait for 1 second before polling again
            poll_response = requests.get(
                f"https://api.replicate.com/v1/predictions/{prediction_id}",
                headers=replicate_headers,
            )
            prediction = poll_response.json()
            prediction_status = prediction.get("status")

        if prediction_status != "succeeded":
            # If prediction failed, return error details
            logger.error(f"Prediction failed: {prediction}")
            return {
                "statusCode": 500,
                "body": json.dumps(
                    {
                        "error": {
                            "message": "Prediction failed.",
                            "details": prediction,
                            "type": "api_error",
                        }
                    }
                ),
                "headers": {"Content-Type": "application/json"},
            }

        # Return the prediction result following OpenAI's API response format
        result = prediction.get("output")
        return {
            "statusCode": 200,
            "body": json.dumps(
                {
                    "id": prediction_id,
                    "object": "text_completion",
                    "created": int(time.time()),
                    "model": "cerebro-phi3.5-vision-instruct",
                    "choices": [
                        {
                            "text": result,
                            "index": 0,
                            "logprobs": None,
                            "finish_reason": "stop",
                        }
                    ],
                    "usage": {
                        "prompt_tokens": len(prompt),
                        "completion_tokens": len(result),
                        "total_tokens": len(prompt) + len(result),
                    },
                }
            ),
            "headers": {"Content-Type": "application/json"},
        }

    except Exception as e:
        # Catch any unexpected exceptions and return a 500 error
        logger.exception("An error occurred during processing.")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": {"message": str(e), "type": "server_error"}}),
            "headers": {"Content-Type": "application/json"},
        }
