from typing import Type, Optional
from pydantic import BaseModel, create_model

from datasheetminer.models.common import ValueUnit, MinMaxUnit

# AI-generated comment:
# These fields are excluded from the schema sent to the LLM because they are
# either provided by the user context (like manufacturer) or generated by the
# application itself (like product_id). This focuses the LLM on extracting only
# the unknown technical specifications from the document.
EXCLUDED_FIELDS = [
    "product_id",
    "product_name",
    "product_type",
    "product_family",
    "manufacturer",
    "datasheet_url",
    "PK",
    "SK",
]


def create_llm_schema(model_class: Type[BaseModel]) -> Type[BaseModel]:
    """
    Dynamically creates a 'lean' Pydantic model for the LLM.

    This function takes a full Pydantic model and creates a new one that is
    more lenient, primarily using `Optional[str]` for complex types. This
    decouples the initial parsing of the LLM's raw output from the final,
    strict validation.

    Args:
        model_class: The original Pydantic model class (e.g., Motor).

    Returns:
        A new, more lenient Pydantic model class for initial parsing.
    """
    field_definitions = {}
    for name, field in model_class.model_fields.items():
        if name not in EXCLUDED_FIELDS:
            # AI-generated comment:
            # For fields that use our custom ValueUnit or MinMaxUnit types,
            # we'll tell the lean schema to just expect a plain string.
            # The full model will handle the more complex validation later.
            if field.annotation in [ValueUnit, MinMaxUnit]:
                field_definitions[name] = (Optional[str], None)
            else:
                # Copy the original field definition for simpler types
                field_definitions[name] = (field.annotation, field)

    # Create a new model dynamically
    lean_model = create_model(
        f"LLM_{model_class.__name__}",
        **field_definitions,
    )
    return lean_model
