"""
Tests for the datasheetminer CLI functionality.

AI-generated comment: This test suite provides comprehensive coverage of the CLI
functionality, including argument validation, response formatting, and error handling.
It uses pytest fixtures and mocking to test the CLI without making actual API calls.
"""

import json
import tempfile
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
from typing import Generator

import pytest
from click.testing import CliRunner

from datasheetminer.__main__ import main, format_response, validate_url, validate_api_key


class TestCLIValidation:
    """Test CLI argument validation functions."""
    
    def test_validate_url_valid_https(self) -> None:
        """Test that valid HTTPS URLs pass validation."""
        ctx = Mock()
        param = Mock()
        result = validate_url(ctx, param, "https://example.com/document.pdf")
        assert result == "https://example.com/document.pdf"
    
    def test_validate_url_valid_http(self) -> None:
        """Test that valid HTTP URLs pass validation."""
        ctx = Mock()
        param = Mock()
        result = validate_url(ctx, param, "http://example.com/document.pdf")
        assert result == "http://example.com/document.pdf"
    
    def test_validate_url_invalid_protocol(self) -> None:
        """Test that invalid URL protocols raise BadParameter."""
        ctx = Mock()
        param = Mock()
        with pytest.raises(Exception):  # click.BadParameter
            validate_url(ctx, param, "ftp://example.com/document.pdf")
    
    def test_validate_url_empty_string(self) -> None:
        """Test that empty URLs pass validation (handled elsewhere)."""
        ctx = Mock()
        param = Mock()
        result = validate_url(ctx, param, "")
        assert result == ""
    
    def test_validate_api_key_valid(self) -> None:
        """Test that valid API keys pass validation."""
        ctx = Mock()
        param = Mock()
        result = validate_api_key(ctx, param, "AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz")
        assert result == "AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz"
    
    def test_validate_api_key_too_short(self) -> None:
        """Test that API keys that are too short raise BadParameter."""
        ctx = Mock()
        param = Mock()
        with pytest.raises(Exception):  # click.BadParameter
            validate_api_key(ctx, param, "short")
    
    def test_validate_api_key_empty(self) -> None:
        """Test that empty API keys raise BadParameter."""
        ctx = Mock()
        param = Mock()
        with pytest.raises(Exception):  # click.BadParameter
            validate_api_key(ctx, param, "")
    
    def test_validate_api_key_whitespace_only(self) -> None:
        """Test that whitespace-only API keys raise BadParameter."""
        ctx = Mock()
        param = Mock()
        with pytest.raises(Exception):  # click.BadParameter
            validate_api_key(ctx, param, "   ")


class TestResponseFormatting:
    """Test response formatting functionality."""
    
    def test_format_response_text(self) -> None:
        """Test text format output (default)."""
        response = "This is a test response from Gemini AI."
        result = format_response(response, "text")
        assert result == response
    
    def test_format_response_json(self) -> None:
        """Test JSON format output."""
        response = "This is a test response from Gemini AI."
        result = format_response(response, "json")
        
        # Parse JSON to verify structure
        parsed = json.loads(result)
        assert parsed["response"] == response
        assert parsed["status"] == "success"
        assert "timestamp" in parsed
    
    def test_format_response_markdown(self) -> None:
        """Test markdown format output."""
        response = "This is a test response from Gemini AI."
        result = format_response(response, "markdown")
        
        assert result.startswith("# Document Analysis Response")
        assert response in result
        assert "*Generated by Datasheetminer CLI*" in result


class TestCLIExecution:
    """Test CLI execution and argument handling."""
    
    @pytest.fixture
    def runner(self) -> CliRunner:
        """Provide a CLI runner for testing."""
        return CliRunner()
    
    @pytest.fixture
    def mock_analyze_document(self) -> Generator[MagicMock, None, None]:
        """Mock the analyze_document function to avoid actual API calls."""
        with patch('datasheetminer.__main__.analyze_document') as mock:
            # Create a mock response that yields chunks
            mock_response = [
                Mock(text="This is the first chunk of the response. "),
                Mock(text="This is the second chunk with more content. "),
                Mock(text="And finally, the third chunk completes the response.")
            ]
            mock.return_value = mock_response
            yield mock
    
    def test_cli_help(self, runner: CliRunner) -> None:
        """Test that CLI help is displayed correctly."""
        result = runner.invoke(main, ['--help'])
        assert result.exit_code == 0
        assert "Datasheetminer CLI" in result.output
        assert "--prompt" in result.output
        assert "--url" in result.output
        assert "--x-api-key" in result.output
    
    def test_cli_version(self, runner: CliRunner) -> None:
        """Test that CLI version is displayed correctly."""
        result = runner.invoke(main, ['--version'])
        assert result.exit_code == 0
        assert "datasheetminer, version 0.1.0" in result.output
    
    def test_cli_missing_required_args(self, runner: CliRunner) -> None:
        """Test that CLI fails when required arguments are missing."""
        result = runner.invoke(main, [])
        assert result.exit_code != 0
        assert "Missing option '--prompt'" in result.output
    
    def test_cli_missing_url(self, runner: CliRunner) -> None:
        """Test that CLI fails when URL is missing."""
        result = runner.invoke(main, ['--prompt', 'test prompt'])
        assert result.exit_code != 0
        assert "Missing option '--url'" in result.output
    
    def test_cli_missing_api_key(self, runner: CliRunner) -> None:
        """Test that CLI fails when API key is missing."""
        # AI-generated comment: Mock the analyze_document function to prevent
        # actual HTTP requests during testing and ensure the test focuses on
        # API key validation rather than network behavior.
        with patch('datasheetminer.__main__.analyze_document'):
            result = runner.invoke(main, [
                '--prompt', 'test prompt',
                '--url', 'https://example.com/test.pdf'
            ])
            assert result.exit_code != 0
            assert "API key is required" in result.output
    
    def test_cli_basic_execution(self, runner: CliRunner, mock_analyze_document: MagicMock) -> None:
        """Test basic CLI execution with all required arguments."""
        result = runner.invoke(main, [
            '--prompt', 'Analyze this document',
            '--url', 'https://example.com/test.pdf',
            '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz'
        ])
        
        assert result.exit_code == 0
        assert "This is the first chunk of the response" in result.output
        assert "This is the second chunk with more content" in result.output
        assert "And finally, the third chunk completes the response" in result.output
        
        # Verify the mock was called correctly
        mock_analyze_document.assert_called_once_with(
            'Analyze this document',
            'https://example.com/test.pdf',
            'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz'
        )
    
    def test_cli_with_output_file(self, runner: CliRunner, mock_analyze_document: MagicMock) -> None:
        """Test CLI execution with output file specified."""
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as tmp_file:
            tmp_path = Path(tmp_file.name)
        
        try:
            result = runner.invoke(main, [
                '--prompt', 'Analyze this document',
                '--url', 'https://example.com/test.pdf',
                '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz',
                '--output', str(tmp_path)
            ])
            
            assert result.exit_code == 0
            assert f"Response saved to: {tmp_path}" in result.output
            
            # Verify file was created and contains the response
            assert tmp_path.exists()
            content = tmp_path.read_text()
            assert "This is the first chunk of the response" in content
            
        finally:
            # Clean up
            if tmp_path.exists():
                tmp_path.unlink()
    
    def test_cli_json_output(self, runner: CliRunner, mock_analyze_document: MagicMock) -> None:
        """Test CLI execution with JSON output format."""
        result = runner.invoke(main, [
            '--prompt', 'Analyze this document',
            '--url', 'https://example.com/test.pdf',
            '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz',
            '--format', 'json'
        ])
        
        assert result.exit_code == 0
        
        # Parse the JSON output
        try:
            parsed = json.loads(result.output)
            assert parsed["status"] == "success"
            assert "This is the first chunk of the response" in parsed["response"]
        except json.JSONDecodeError:
            pytest.fail("Output is not valid JSON")
    
    def test_cli_markdown_output(self, runner: CliRunner, mock_analyze_document: MagicMock) -> None:
        """Test CLI execution with markdown output format."""
        result = runner.invoke(main, [
            '--prompt', 'Analyze this document',
            '--url', 'https://example.com/test.pdf',
            '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz',
            '--format', 'markdown'
        ])
        
        assert result.exit_code == 0
        assert result.output.startswith("# Document Analysis Response")
        assert "This is the first chunk of the response" in result.output
        assert "*Generated by Datasheetminer CLI*" in result.output
    
    def test_cli_verbose_mode(self, runner: CliRunner, mock_analyze_document: MagicMock) -> None:
        """Test CLI execution with verbose logging enabled."""
        result = runner.invoke(main, [
            '--prompt', 'Analyze this document',
            '--url', 'https://example.com/test.pdf',
            '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz',
            '--verbose'
        ])
        
        assert result.exit_code == 0
        # Verbose mode should show progress information
        assert "Received chunk:" in result.output
    
    def test_cli_short_options(self, runner: CliRunner, mock_analyze_document: MagicMock) -> None:
        """Test CLI execution with short option names."""
        result = runner.invoke(main, [
            '-p', 'Analyze this document',
            '-u', 'https://example.com/test.pdf',
            '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz'
        ])
        
        assert result.exit_code == 0
        assert "This is the first chunk of the response" in result.output
    
    def test_cli_invalid_url(self, runner: CliRunner) -> None:
        """Test CLI execution with invalid URL format."""
        result = runner.invoke(main, [
            '--prompt', 'Analyze this document',
            '--url', 'invalid-url',
            '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz'
        ])
        
        assert result.exit_code != 0
        assert "URL must start with http:// or https://" in result.output
    
    def test_cli_invalid_api_key(self, runner: CliRunner) -> None:
        """Test CLI execution with invalid API key."""
        result = runner.invoke(main, [
            '--prompt', 'Analyze this document',
            '--url', 'https://example.com/test.pdf',
            '--x-api-key', 'short'
        ])
        
        assert result.exit_code != 0
        assert "API key appears to be too short" in result.output


class TestCLIErrorHandling:
    """Test CLI error handling and edge cases."""
    
    @pytest.fixture
    def runner(self) -> CliRunner:
        """Provide a CLI runner for testing."""
        return CliRunner()
    
    def test_cli_analysis_error(self, runner: CliRunner) -> None:
        """Test CLI handling of analysis errors."""
        with patch('datasheetminer.__main__.analyze_document') as mock:
            mock.side_effect = Exception("API rate limit exceeded")
            
            result = runner.invoke(main, [
                '--prompt', 'Analyze this document',
                '--url', 'https://example.com/test.pdf',
                '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz'
            ])
            
            assert result.exit_code != 0
            assert "Error: API rate limit exceeded" in result.output
    
    def test_cli_empty_response(self, runner: CliRunner) -> None:
        """Test CLI handling of empty responses from Gemini."""
        with patch('datasheetminer.__main__.analyze_document') as mock:
            # Mock empty response
            mock.return_value = []
            
            result = runner.invoke(main, [
                '--prompt', 'Analyze this document',
                '--url', 'https://example.com/test.pdf',
                '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz'
            ])
            
            assert result.exit_code != 0
            assert "No response received from Gemini AI" in result.output
    
    def test_cli_response_without_text_attribute(self, runner: CliRunner) -> None:
        """Test CLI handling of responses without text attribute."""
        with patch('datasheetminer.__main__.analyze_document') as mock:
            # Mock response without text attribute
            mock.return_value = [Mock(spec=[])]
            
            result = runner.invoke(main, [
                '--prompt', 'Analyze this document',
                '--url', 'https://example.com/test.pdf',
                '--x-api-key', 'AIzaSyC1234567890abcdefghijklmnopqrstuvwxyz'
            ])
            
            assert result.exit_code != 0
            assert "No response received from Gemini AI" in result.output


if __name__ == "__main__":
    pytest.main([__file__])
